# 목표
- 1단계 구현하는 데에만 마음이 급해서 개념 공부를 하지 않고 무작정 구현을 했습니다.
- 2단계의 경우 작성되어 있는 코드에 대한 개념 공부를 하고, 구현 동작을 파악하는 부분으로 목표를 잡을 예정입니다.
  - 호눅스께서 마스터 클래스에서 처럼 각각의 코드에 대한 동작 방식을 질문하신다고 생각하고 파악하도록 하겠습니다!

# 부족한 개념 공부
- io vs nio
  - I/O란? https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/io/package-summary.html
    - Input과 Output의 약자로 입출력을 의미함
    - 입출력의 간단한 예로 키보드로 텍스트를 입력하고, 모니터로 입력한 텍스트를 출력하는 것
    - 데이터 스트림, 직렬화 및 파일 시스템을 통해 시스템 입력 및 출력을 제공합니다. 별도로 명시하지 않는 한 이 패키지의 클래스나 인터페이스에 있는 생성자나 메서드에 null 인수를 전달하면 NullPointerException이 발생합니다.
  - NIO란?
    - 자바 4부터 새로운 입출력(New Input/Output) 이라는 뜻에서 java.nio 패키지가 포함되었는데, 자바 7로 버전업하면서 IO와 NIO 사이의 일관성 없는 클래스 설계를 바로 잡고 비동기 채널 등의 네트워크 지원을 대폭 강화한 NIO.2API가 추가되었다.
    - NIO에서 제공하는 패키지
      - nio 패키지 
        - java.nio - 다양한 버퍼 클래스
        - java.nio.channels - 파일 채널, TCP 채널 UDP 채널 등의 클래스
        - java.nio.chennels.spi - java.nio.channels 패키지를 위한 서비스 제공자 클래스
        - java.nio.charset - 문자셋, 인코더, 디코더 API
        - java.nio.charset.spi - java.nio.charset 패키지를 위한 서비스 제공자 클래스
        - java.nio.file - 파일 및 파일 시스템에 접근하기 위한 클래스
        - java.nio.file.attribute - 파일 및 파일 시스템의 속성에 접근하기 위한 클래스
        - java.nio.file.spi - java.nio.file 패키지를 위한 서비스 제공자 클래스
  - IO와 NIO의 차이점
    - IO와 NIO는 데이터를 입출력한다는 목적은 동일하지만 방식에서 크게 차이가 난다
    - 입출력 방식 - IO : 스트림, NIO : 채널
    - 버퍼 방식 - IO : 넌버퍼(Non-Buffer), NIO : 버퍼(Buffer)
    - 비동기 방식 - IO : 지원 안 함, NIO : 지원
    - 블로킹 / 넌블로킹 방식 - IO : 블로킹 방식만 지원, NIO : 블로킹 / 넌블로킹 방식 모두 지원
    - IO는 스트림 기반이다.
      - 스트림은 입력 스트림과 출력 스트림이 구분되어 있다 - 데이터를 읽기위해 입력 스트림을 생성하고, 데이터를 출력하기 위해 출력 스트림을 생성해야 한다.
    - NIO는 채널 기반이다.
      - 채널은 스트림과 달리 양방향으로 입력과 출력이 가능하다. - 입력과 출력을 위한 별도의 채널을 만들 필요가 없다.
    - 넌버퍼 vs 버퍼
      - IO 넌버퍼(Non-Buffer)
      - IO에서는 출력 스트림이 1바이트를 쓰면 입력 스트림이 1바이트를 읽는다. - 이런 시스템은 대체로 느리다. 그래서 버퍼(Buffer)를 사용해서 복수 개의 바이트를 한꺼번에 입력받고 출력하는 것이 좋다. 그래서 IO는 버퍼를 제공해주는 BufferedInputStream, BufferedOutputStream 을 연결해서 사용하기도 한다.
      - NIO 버퍼(Buffer)
      - NIO는 기본적으로 버퍼를 사용하여 입출력을 한다.
      - 채널은 버퍼에 저장된 데이터를 출력하고, 입력된 데이터를 버퍼에 저장한다.
- 블로킹 / 넌블로킹 -> 전체적인 작업의 흐름 자체를 막냐 안 막냐
  - 단어 그대로 현재 작업이 block(차단, 대기) 되느냐 아니냐에 따라 다른 작업을 수행할 수 있는지에 대한 관점이다.
  - 요청과 응답의 순서가 보장되지 않는다.
  - 블로킹 
    - 한 프로세스나 스레드가 작업을 수행하는 동안 다른 작업을 수행할 수 없는 상태를 의미
    - 주로 IO작업을 수행할 때 발생, 예를 들어 파일을 읽거나 네트워크로부터 데이터를 받아올 때, 해당 작업이 완료될 때까지 기다리는 동안 프로그램이 멈추는 것을 블로킹이라고 한다.
    - 블로킹 작업은 대기 시간이 길어질 수 있으며, 다른 작업을 수행하지 못하기 때문에 자원을 효율적으로 사용하지 못할 수 있다.
  - 논블로킹
    - 논블로킹은 한 작업이 다른 작업과 독립적으로 실행되어, 작업이 완료되지 않았더라도 다른 작업을 수행할 수 있는 상태를 의미한다.
    - 주로 IO 작업을 수행할 때 사용된다. 예를들어, 파일을 읽거나 네트워크로부터 데이터를 받아올 때, 해당 작업이 완료될 때까지 기다리지 않고 다른 작업을 수행하는 것을 논블로킹이라고 한다.
    - 논블로킹 작업은 대기 시간이 짧아지고, 다른 작업을 수행할 수 있기 때문에 자원을 효율적으로 사용할 수 있다.
- 동기 / 비동기 -> 전체적인 작업에 대한 순차적인 흐름 유무
  - 요청한 작업에 대해 완료 여부를 신경 써서 작업을 순차적으로 수행할지 아닌지에 대한 관점
  - 요청과 응답의 순서가 보장된다.
- Socket - 네트워크 상에서 데이터를 주고받을 수 있는 통로를 의미한다. 소켓은 TCP/IP 프로토콜을 기반으로 동작하며, 클라이언트와 서버 간에 양방향 통신을 가능하게 한다.
  - ServerSocket
    - ServerSocket 은 서버 프로그램이 클라이언트의 연결 요청을 수락하고, 실제 통신을 담당하는 소켓이다.
    - 서버 소켓은 서버 프로그램에서 포트를 열어서 클라이언트의 연결 요청을 수신하고, 클라이언트와 통신할 소켓을 생성한다.
    - 주로 서버 프로그램의 초기화 단계에서 사용되며, 클라이언트의 연결 요청을 기다리는 역할을 한다.
  - 리스닝 소켓
    - 리스닝 소켓은 대기 상태에 있는 서버 소켓을 의미한다.
    - 서버 소켓이 클라이언트의 연결 요청을 받기 위해 대기하는 상태를 의미하며, 이때 리스닝 소켓이 사용된다.
    - 클라이언트의 연결 요청이 들어오면, 리스닝 소켓은 이를 감지하여 새로운 연결된 소켓을 생성하고, 해당 소켓으로 통신을 진행한다.
  - 연결된 소켓
    - 연결된 소켓은 클라이언트와 서버 간의 실제 데이터 통신을 담당하는 소켓이다.
    - 서버 소켓이 클라이언트의 연결 요청을 수락하면, 새로운 소켓을 생성하고 해당 소켓으로 클라이언트와 서버 간의 데이터 교환을 시작
    - 이 소켓은 서버 소켓과 별개로 생성되며, 클라이언트와의 통신을 위해 사용된다.
- 포트
  - 포트는 컴퓨터 네트워크에서 특정 프로세스나 서비스를 식별하기 위한 번호이다. 네트워크 통신은 IP 주소와 포트 번호의 조합으로 이루어지며, 이를 통해 데이터가 정확한 목적지로 전송된다.
  - 네트워크 통신에서 포트 번호는 송신자와 수신자 사이의 데이터 흐름을 지시하는 역할을 한다. 송신자는 수신자의 IP 주소와 포트 번호를 사용하여 데이터를 전송하고, 수신자는 해당 포트에서 수신하여 적절한 프로세스에게 데이터를 전달한다.
  - 포트는 네트워크 통신에서 컴퓨터 내의 특정 프로그램이나 서비스를 식별하는 데 사용되는 번호이다.
- Logger
  - 로깅 작업을 수행하는 주요 클래스이다. 이 클래스를 사용해서 로그 메시지를 생성하고 기록할 수 있다.
  - Logger 객체는 클래스 레벨이나 패키지 레벨에서 생성되며 이름을 통해 식별한다.
  - 로거는 다양한 로그 레벨을 지원하여 각각 다른 중요도와 상세도의 로그를 기록할 수 있다.
  - debug
  - 가장 상세한 로그 레벨로, 프로그램의 내부 작동에 대한 자세한 정보를 기록한다.
  - 주로 프로그램의 동작을 추적하고 버그를 찾거나 문제를 해결하는 데 사용된다.
  - info
  - 일반적인 정보를 기록하는 레벨이다. 프로그램의 실행 상태나 중요한 이벤트를 기록하는 데 사용된다.
  - 예를 들어, 프로그램이 시작되었거나 특정 작업이 완료되었을 때 중요한 정보를 기록하는데 사용된다.
- LoggerFactory
  - 로거 객체를 생성하고 관리하는 역할을 담당하는 팩토리 클래스이다.
  - 일반적으로는 로거를 직접 생성하는 대신 LoggerFactory 를 통해 로거를 가져와 사용한다.
  - LoggerFactory를 사용하면 코드의 유연성과 확장성을 높일 수 있다. 로거의 생성 방법과 설정을 중앙 집중화하여 관리할 수 있다.
- InputStream
  - InputStream은 바이트 단위로 데이터를 읽는 입력 스트림을 나타냅니다.
  - 네트워크에서 데이터를 읽거나 파일에서 데이터를 읽는 데 사용된다.
  - 예를 들어, 클라이언트와 서버 간의 통신에서 서버가 클라이언트로부터 데이터를 읽을 때 사용된다.
  - getInputStream -> 클라이언트 거를 읽어옴
    - 소켓에서 입력 스트림을 가져온다. 즉, 클라이언트로부터 데이터를 읽는데 사용된다.
- OutputStream
  - 바이트 단위로 데이터를 쓰는 출력 스트림을 나타낸다.
  - 네트워크에 데이터를 쓰거나 파일에 데이터를 쓰는 데 사용된다.
  - 예를 들어, 서버가 클라이언트에게 데이터를 보낼 때 사용된다.
  - getOutputStream
    - 소켓에서 출력 스트림을 가져온다. 즉, 클라이언트에게 데이터를 보내는 데 사용된다. 
- getInetAddress
  - 소켓의 연결된 반대편 피어의 IP 주소를 반환한다.
  - 즉, 해당 소켓이 연결된 상대방 IP 주소를 확인할 때 사용된다.
- File - java.io 패키지에서 제공하는 File 클래스는 파일 및 폴더 정보를 제공해주는 역할을 한다.
  - exists
    - 파일 또는 디렉토리가 존재하는지 여부를 나타내는 boolean 값을 반환한다.
  - isDirectory
    - 저장된 경로에 있는 파일이나 디렉토리가 디렉토리인지 여부를 확인한다.
- ByteArrayOutputStream
  - 바이트 배열에 데이터를 쓰는데 사용된다. 데이터를 바이트 배열로 캡처하고 필요에 따라 이를 출력 스트림으로 변환할 수 있다.
- FileInputStream
  - 파일에서 바이트 단위로 데이터를 읽는데 사용된다. 파일로부터 데이터를 읽어와 프로그램에서 처리할 수 있게 한다. 
- toByteArray
  - 객체에 저장된 데이터를 바이트 배열로 반환한다. 데이터를 메모리에 쓰는 용도로 사용되며 데이터를 쓸 때마다 내부 버퍼에 쌓인다. 해당 메소드를 호출하면 내부 버퍼의 데이터가 바이트 배열로 반환된다.
- DataOutputStream
  - 다양한 데이터 유형을 이진 형식으로 출력하는데 사용된다. 기본 데이터 유형 및 문자열을 바이트 스트림으로 변환하여 출력할 수 있다.
- writeBytes
  - DataOutputStream 클래스의 메소드 중 하나로, 문자열을 바이트 단위로 파일에 출력하는 데 사용된다.
- Concurrent 패키지 
- 스레드 풀 종류와 선정 이유
  - newFixedThreadPool(int nThreads): 고정된 크기의 스레드 풀을 생성합니다. 스레드 풀의 크기가 고정되어 있으며, 작업을 제출하면 스레드 풀에 있는 스레드가 사용됩니다. 이 스레드 풀은 작업 큐에 있는 모든 작업을 순차적으로 처리합니다.
  - newCachedThreadPool(): 필요에 따라 스레드를 동적으로 생성하는 스레드 풀을 생성합니다. 작업이 있으면 새로운 스레드를 생성하고, 작업이 없으면 이전에 생성된 스레드를 재사용합니다. 스레드가 60초 동안 사용되지 않으면 제거됩니다.
  - newSingleThreadExecutor(): 하나의 스레드만을 사용하는 스레드 풀을 생성합니다. 스레드가 종료되면 새로운 스레드가 생성됩니다. 작업 큐에 있는 모든 작업을 순차적으로 처리합니다.
  - newScheduledThreadPool(int corePoolSize): 지정된 개수의 스레드를 갖는 스케줄된 스레드 풀을 생성합니다. 주어진 시간 또는 주기에 따라 작업을 실행할 수 있습니다.
  - newWorkStealingPool(): 작업을 각 스레드에 대해 FIFO(First-In-First-Out) 방식이 아닌 LIFO(Last-In-First-Out) 방식으로 배정하여 스레드 간의 작업 로드를 균형 있게 유지하는 스레드 풀을 생성합니다.
- get과 post의 차이
  - get: 데이터를 URL 의 쿼리 문자열에 포함하여 전송한다. 데이터는 URL의 끝에 '?'를 붙이고, 이름과 값 쌍을 key=value 형식으로 나열하여 전달한다.
  - post: 데이터를 HTTP 요청 본문(body)에 포함하여 전송한다. 데이터는 보통 폼을 통해 전송되며, 요청의 본문에 숨겨져 전송되므로 get 방식보다 보안적으로 더 안전하다. post는 주로 데이터를 서버에 제출하거나 업데이트할 때 사용된다.
  - GET은 정보를 요청하고, POST는 데이터를 제출하거나 업데이트하는 데 사용됩니다. 보안과 데이터 양 측면에서 POST가 더 안전하고 효율적입니다.
- GET 메서드 사용 예시
  - 웹 검색: 사용자가 검색어를 입력하고 검색 버튼을 클릭할 때, 브라우저는 입력된 검색어를 GET 요청의 일부로 URL에 추가하여 서버에 보냅니다. 예를 들어, https://www.example.com/search?q=keyword와 같은 URL을 생성합니다.
  - 페이지 조회: 사용자가 웹 페이지를 방문할 때, 브라우저는 해당 페이지에 대한 GET 요청을 보냅니다. 이 요청은 페이지의 URL을 사용하여 보내지며, 서버는 해당 페이지의 콘텐츠를 응답으로 전송합니다.
- POST 메서드 사용 예시:
  - 회원 가입: 사용자가 회원 가입 양식을 작성하고 제출할 때, 브라우저는 이 정보를 POST 요청의 본문에 포함하여 서버에 전송합니다. 이 때, 사용자의 개인 정보(예: 이름, 이메일, 비밀번호 등)가 요청 본문에 안전하게 포함됩니다.
  - 게시글 작성: 사용자가 게시글을 작성하고 게시 버튼을 클릭할 때, 브라우저는 게시글 내용을 POST 요청의 본문에 포함하여 서버에 전송합니다. 이를 통해 서버는 사용자가 작성한 게시글을 안전하게 저장하고 처리할 수 있습니다.
- 상대 경로와 절대 경로란?
  - 경로 - 프로그래밍 언어, 운영체제 등에서 컴퓨터의 파일을 찾아가는 방법을 
- HTTP - https://code-overflow.tistory.com/entry/%EB%AA%A8%EB%93%A0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-HTTP-%EC%9B%B9-%EA%B8%B0%EB%B3%B8-%EC%A7%80%EC%8B%9D-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%99%9C%EC%9A%A9-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90%EC%84%9C-%EC%84%9C%EB%B2%84%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%86%A1
- httprequest
  - 클라이언트가 서버에게 보내는 요청을 나타냅니다.
- httpresponse
  - 서버가 클라이언트에게 보내는 응답을 나타냅니다.

# 1단계 코드 리뷰
- System.out.println()은 Java에서 콘솔에 출력을 하기 위한 메서드입니다. 서버 프로젝트에서는 일반적으로 System.out.println()을 사용하지 않는다.
  - Logging Framework 사용: 서버 애플리케이션은 보통 로깅 프레임워크를 사용하여 로그를 관리합니다. 로깅 프레임워크를 사용하면 로그 메시지를 다양한 레벨에 따라 필터링하고, 파일이나 데이터베이스 등에 기록할 수 있습니다. 또한, 로그 메시지의 형식을 지정할 수 있어서 메시지의 유용성을 향상시킬 수 있습니다.
  - 로깅 레벨 제어: 로깅 프레임워크를 사용하면 로그 메시지의 레벨을 설정할 수 있습니다. 이를 통해 디버깅, 정보, 경고, 오류 등 다양한 레벨의 로그를 관리할 수 있습니다. 디버깅 중에는 상세한 정보를 출력하고, 운영 환경에서는 중요한 메시지만 출력할 수 있습니다.
  - 성능: System.out.println()은 간단한 테스트나 개발 시에는 유용하지만, 실제 서버 환경에서는 성능 저하를 초래할 수 있습니다. 특히, 동시에 여러 스레드에서 System.out.println()을 호출하면 출력이 병목이 될 수 있습니다.
  - 가시성 제어: System.out.println()은 콘솔에만 출력되므로, 서버 애플리케이션이 여러 머신에서 실행되는 경우 로그를 집중적으로 모니터링하기 어렵습니다. 대신 로깅 프레임워크를 사용하면 로그 메시지를 중앙 집중식 로그 서버로 전송하여 모니터링 및 분석을 수행할 수 있습니다.
  - 유연성: System.out.println()은 출력 형식이 고정되어 있습니다. 반면에 로깅 프레임워크를 사용하면 출력 형식을 유연하게 변경할 수 있습니다. 예를 들어, 날짜/시간 형식, 로그 레벨, 스레드 이름 등을 포함할 수 있습니다.

# 궁금한 점
- debug 레벨의 로그는 보통 개발 중에만 활성화되고, info 레벨의 로그는 개발과 운영 환경에서 모두 활성화될 수 있습니다.
  - 어떤 코드는 debug를 사용하고, 어떤 코드는 info를 사용하는 이유가 뭘까? 비슷한 역할로 보인다.







