# be-was-2024
코드스쿼드 백엔드 교육용 WAS 2024 개정판

## 🍪 Step5 쿠키를 이용한 로그인
### ⚒ step5 기능 구현 목록
- [x] 로그인 시 데이터를 서버로 전송하는 기능
- [x] 들어온 로그인 요청을 적절하게 처리하여 응답하는 기능
  - [x] 로그인 요청이 기존 User DB에 있는 내용과 일치하는지 확인
  - [x] 로그인 성공 시, 응답할 헤더값에 SID로 세션 ID를 넣어주기
- [x] 로그아웃 요청에 응답하는 기능
  - [x] 만료된 쿠키를 응답 헤더에 세팅한다
  - [x] 해당하는 세션을 삭제한다
- [x] 세션 아이디에 해당하는 User 정보에 접근하는 기능
- [x] 로그인 성공 시 메인 화면으로 이동하는 기능
- [x] 로그인 실패 시 실패 화면으로 이동하는 기능
- [ ] 로그인이 되어 있지 않은 경우에 main/index.html로 접근하는 경우 처리 필요

### 🤔 설계 및 고민
#### - 그동안 response body를 핸들링 하는 객체의 구조에 문제가 있었음
- 기존에는 POST인 경우에, response body를 만드는 과정과 리소스 요청 종류를 처리하는 방법을 동일시해서 생각하고 있었던 것 같다.
- 그러니까 responseBodyHandler, 즉 body를 만드는 역할을 하던 객체에서 리소스 요청인 create 처리까지 함께 하고 있었고, 심지어 그 결과는 body와 아무런 관련도 없는 상태였다.
- create 요청은 새로 생긴 사용자 정보를 저장만 하는 거라서 이때까지 문제가 없었는데, login은 로그인 한 결과가 필요하고 그 결과에 맞춰서 헤더 내용도 추가해야 하고, 리다이렉션도 각자 다른 페이지로 해줘야 하는 등 후속 동작이 필요했다.
- 그렇기 때문에 기존 구조로는 도저히 정상적으로 login을 처리 할 방법이 떠오르지 않았으며 리소스를 처리하는 과정(현재 responseBodyHandler 내부에 있는)과 header를 만드는 과정을 어떻게 협력하도록 만들 것인지 고민이 많았다.  

&rarr; 결국 대규모 리펙토링 진행!

#### - 리펙토링 진행.. 크게 GET과 POST를 담당할 객체를 만들고, 다시 여러 요청이 들어올 수 있는 POST는 요청별로 또 다시 객체로 나누자
- 첫번째로 요청 method의 종류로 나눴고, 더 분기해야할 부분이 있다면 다시 그 내부에서 나눠지도록 했다.
- create, login, logout 등의 처리 하나하나를 따로 담당하는 핸들러들을 만들어 관리했는데, if 문을 남발하지 않기 위한 방법으로, 이 핸들러들이 모두 같은 인터페이스를 구현하도록 했다.
- 한가지 고민은, 이렇게 수정하고 나니 기존과는 다르게 각각의 핸들러에서 body와 header를 만드는 일을 담당하게 되었는데 중복되는 부분이 생기는 듯 해서 그 점이 고민스럽다.

#### - 쿠키에서 세션 아이디를 받아, 어떻게 로그인을 유지하게 처리할 것인가?
- 클라이언트가 로그인을 성공하고 나서부터의 요청은 이제 랜덤 숫자로 이루어진 세션id를 헤더에 포함하도록 구현했다.
- 그런데 세션id를 식별하고 처리할 역할의 객체가 필요하다. 어떻게 하면 좋을까?  

&rarr; 세션 id와 해당 유저의 로그인 정보를 연결한 Map을 만들고 이를 관리할 SessionHandler 구현

#### - 로그아웃의 구현
- 로그아웃은 어떻게 처리할까? 서버에서 관리하는 세션 정보만 삭제하면 되는걸까? 아니면 쿠키까지 삭제하도록 해야 할까?
- 처음에는 서버 쪽에서 관리하는 세션만 삭제하면 되지 않을까 싶었고, 쿠키는 브라우저 쪽 소관인데 뭘 어떻게 삭제를 하지? 라고 생각했는데, 쿠키에 만료 날짜를 설정하는 것을 통해
삭제를 요청할 수 있다는 것을 알게 되어 적용하였다.  

&rarr; 세션을 삭제함과 동시에 응답으로 만료된 쿠키를 헤더에 전송해서 클라이언트에게 쿠키를 삭제하도록 요청

### 📚 학습
#### 랜덤 숫자를 생성할 수 있는 난수 스트림
- [Random 클래스](https://docs.oracle.com/javase/8/docs/api/java/util/Random.html)를 이용해여 난수 스트림을 만들 수 있다!
- IntStream, LongStream, DoubleStream 등을 만들 수 있는 메서드를 지원하며 해당 메서드들을 파라미터 없이 호출할 경우 무제한 스트림이 생성되기 때문에,
사용 시에는 사이즈를 지정해주거나 limit으로 제한해주어야 한다.
- 랜덤 수의 범위를 설정해서 호출할 경우, randomNumberOrigin 값은 포함(inclusive)되고, randomNumberBound 값은 포함되지 않는다.(exclusive)
```
return new Random().ints(5, 0, 10)
                   .mapToObj(String::valueOf).collect(Collectors.joining());
```
#### 호눅스가 말씀해주신 IntelliJ에서 바로 HTTP 요청 보내는 법 시도!
```
### 회원가입
POST http://localhost:8080/create HTTP/1.1

{"userId":"1","name":"1","password":"1","email":"1"}

### 로그인
POST http://localhost:8080/login HTTP/1.1

{"userId":"1","password":"1"}

### 로그아웃
POST http://localhost:8080/logout HTTP/1.1
Cookie: sid=05623

{}

### 확인을 위한 재요청
GET http://localhost:8080/ HTTP/1.1
```

#### JUnit과 AssertJ에서의 actual과 expected
- 테스트 시, actual과 expected 용어에 대해 너무 헷갈려서 잊지 않기 위해 정리.
- actual은 실제값 &rarr; 이는 내가 실제로 작성한 코드의 값이다. 즉 틀릴 수도 있고 맞을 수도 있는 값
- expected는 기대값 &rarr; 이는 테스트가 올바르게 진행되었다면 이렇게 나올 것이라고 예상하는 값이다. 즉 정답이라고 할 수 있음
```
// 앞에 내가 작성한 코드를, 뒤에 정답이 되는 값을 집어넣어야 함
assertThat(actual).isEqualTo(expected);
```
#### Session과 Cookie [📑](https://www.tutorialspoint.com/What-is-the-difference-between-session-and-cookies)

- 쿠키와 세션은 둘 다 정보를 저장하는데 사용한다.
- 차이점!  
  → 쿠키는 클라이언트의 컴퓨터에만 저장  
  → 세션은 클라이언트의 컴퓨터와 서버에 모두 저장 (세션이 클라이언트에도 저장된다라는 의미는 세션 식별자가 클라이언트에 저장되기 때문인 것으로 생각된다)
- what is Cookie?
  - 쿠키는 클라이언트 컴퓨터에 저장되는 최대 4KB의 크기를 가지는 작은 텍스트 기반 파일이며, 해당 클라이언트의 브라우저에서만 접근할 수 있다.
  - 클라이언트가 어떤 웹사이트에 처음으로 접속하면 웹사이트는 쿠키에 많은 정보를 담아서 클라이언트의 컴퓨터로 전송한다. 그리고 클라이언트가 웹사이트를 이용하는 동안 일어나는 모든 활동을 추적한다.
  - 쿠키는 누구나 읽을 수 있는 텍스트 기반 파일이 클라이언트 측에 저장되는 것이기 때문에  안전하지 않다.
  - 쿠키는 만료 시점을 쿠키 저장시에 설정하게 되며, 클라이언트는 쿠키 옵션을 꺼버리거나 삭제할 수도 있다.
  - 쿠키는 같은 도메인에서만 유효하다.
- why use Cookie?
  - http는 상태 비저장 프로토콜로 전송되는 요청들은 모두 독립적이며, 서버에 클라이언트에 관한 정보를 따로 저장하지 않는다. 그래서 클라이언트의 정보가 필요할 경우에 쿠키나 세션을 사용하게 되는 것.
  - 세션과 별개로 쿠키를 사용하는 이유 중 하나는, 세션은 서버 자원을 쓰기 때문에 모든 정보를 세션에 저장할 경우 관련해서 부하가 일어날 수 있기 때문이라고 한다.
- what is Session?
  - 세션 또한 상태를 저장하지 않는 http의 특성을 보완하기 위해 사용된다. 만약 세션이 없다면, 사용자가 장바구니에 원하는 물건을 담은 뒤에, 다른 물건을 보러 페이지를 이동시키면 장바구니의 내용이 계속 저장되지 않고 날아가 버릴 것!
  - 세션은 클라이언트의 정보를 계속 유지하며 활용할 수 있도록 서버 측에 저장하는 방법이다.
  - 간단하게 말하자면 세션은 한 사용자가 접속해서 요청과 응답을 반복하며 활동을 하는 기간이며, 이 기간동안은 이 사용자의 정보를 계속 가지고 있는 것이다. 데이터의 단위 같은 개념
  - 세션은 사용자의 로그인이 이루어지면 세션 변수에 이에 관한 정보를 저장해 두고, 다음 요청이 들어왔을 때 서버가 이 세션 변수를 확인하여 사용자를 인식하게 된다.
  - 이 세션 기간은 홈페이지나 프로그램에 엑세스 할 때 시작되어서 이를 종료하거나, 컴퓨터를 종료할 때 종료된다.
- why use Session?
  - 민감한 정보들을 상대적으로 안전한 서버에 안전하게 저장하기 위해서 사용한다.
  - 쿠키를 지원하지 않는 웹 브라우저인 경우 쿠키 대신 세션을 사용할 수 있다.
- how session work? [📑](https://medium.com/@hendelRamzy/how-session-and-cookies-works-640fb3f349d1)
  - 사용자가 웹사이트에 로그인하면 세션이 생성되고, 이 세션에서는 키-값 형태의 세션 변수가 설정된다.
  - 생성된 세션은 고유 ID를 가지게 되며, 생성된 세션 ID가 사용자의 브라우저에 쿠키로 저장되고, 세션 데이터는 서버에 저장된다.
  - 이후 사용자가 서버로 요청을 보내게 되면, 서버는 사용자의 쿠키에서 세션 ID를 검색해서 해당 데이터를 찾는다.